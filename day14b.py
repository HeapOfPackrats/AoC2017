#http://adventofcode.com/2017/day/14
#see URL for full specifications
#we build a 128x128 grid of 0s and 1s
#each row of the grid is generated by knot hash (day 10's puzzle)
#each row's knot hash's input is the concat of a given string, "-", and row #
#we take the binary of the knot hash's 32 chars to get 128 chars of 0s and 1s
#0s represent "empty" squares, 1s represent "used"
#for part b of day 14, we are counting distinct groups of connected squares
#where connected = cardinally or diagonally adjacent squares

from day10b import denseHash, seqToHexStr
from day12b import findGroupMembers, buildGroups

def main():
    with open("input14.txt") as inputFile:
        puzzleStr = inputFile.read()
    rows = makeRows(puzzleStr)
    usedSquares = countUsedSquares(rows)
    for row in rows:
        print(row)
    print("\n{} squares are used".format(usedSquares))
    groups = buildGroups(findConnections(rows))
    print("There are {} distinct groups/regions of connected squares".format(len(groups)))

def hexStrToBitStr(hexStr):
    bitStr = f'{int(hexStr, 16):0>128b}'
    return bitStr

def makeRows(puzzleStr):
    rows = list()
    for i in range(128):
        puzzleInput = puzzleStr + "-" + str(i)
        sequence = list(range(0, 256))
        lengths = list(map(lambda c: ord(c), puzzleInput)) #convert all chars to ASCII code
        lengths += [17, 31, 73, 47, 23] #append sequence specified by specs
        row = hexStrToBitStr(seqToHexStr(denseHash(sequence, lengths)))
        rows.append(row)
    return rows

def countUsedSquares(rows):
    usedSquares = 0
    for row in rows:
        for char in row:
            usedSquares += int(char)
    return usedSquares

#take in a list of strings of 0s and 1s generated by main()
#return a dict of squares and their connected squares as key:[values] pairs 
#that is readable by findGroupMembers and buildGroups
def findConnections(rows):
    connections = dict()
    for i in range(len(rows)):
        for j in range(len(rows[i])):
            if rows[i][j] == "1":
                key = 1000*i + j
                values = list()
                if i > 0 and rows[i-1][j] == "1":
                    values.append((i-1)*1000 + j)
                if i < len(rows)-1 and rows[i+1][j] == "1":
                    values.append((i+1)*1000 + j)
                if j > 0 and rows[i][j-1] == "1":
                    values.append(i*1000 + j-1)
                if j < len(rows[i])-1 and rows[i][j+1] == "1":
                    values.append(i*1000 + j+1)
                #for square without neighbors, define connection to itself
                if not values:
                    values.append(key)
                connections.update({key:values})
    return connections
        
if __name__ == "__main__":
    main()